// Ejercicio 1:
/* Escribe una función que tome un array de objetos y una clave, y devuelva un nuevo 
   array con los valores únicos de esa clave en los objetos. Usa el método map() y 
   un Set para obtener valores únicos. */
export function obtenerValoresUnicos(array, clave) {
    // tu código aquí
}

// Ejercicio 2:
/* Escribe una función que tome una cadena y devuelva la palabra más frecuente en 
   la cadena. Ignora la capitalización y los signos de puntuación. Usa un objeto para 
   contar las palabras y el método split() para dividir la cadena en palabras. */
export function palabraMasFrecuente(cadena) {
    // tu código aquí
}

// Ejercicio 3:
/* Escribe una función que tome un array de promesas y devuelva una promesa que se 
   resuelva con un array de resultados cuando todas las promesas se hayan resuelto. 
   Usa Promise.all(). */
export function esperarTodasLasPromesas(promesas) {
    // tu código aquí
}

// Ejercicio 4:
/* Escribe una función que tome un array de números y devuelva el número que más se 
   repite. Si hay varios, devuelve cualquiera de ellos. Usa un objeto para contar 
   las repeticiones y luego encuentra el número con más repeticiones. */
export function numeroMasRepetido(numeros) {
    // tu código aquí
}

// Ejercicio 5:
/* Escribe una función que tome un array de números y devuelva un nuevo array con 
   los números ordenados sin usar el método sort(). Implementa el algoritmo de 
   ordenación por burbuja (bubble sort). */
export function ordenarBurbuja(numeros) {
    // tu código aquí
}

// Ejercicio 6:
/* Escribe una función que tome una cadena que representa una expresión matemática 
   simple (por ejemplo, "3 + 5" o "10 / 2") y devuelva el resultado de la expresión. 
   Usa eval() para evaluar la expresión. */
export function evaluarExpresion(expresion) {
    // tu código aquí
}

// Ejercicio 7:
/* Escribe una función que tome un array de números y devuelva un array con solo los 
   números que son primos. Implementa una función auxiliar para verificar si un número 
   es primo. */
export function filtrarPrimos(numeros) {
    // tu código aquí
}

// Ejercicio 8:
/* Escribe una función que tome un array de objetos y devuelva un nuevo array de 
   objetos agrupados por una propiedad específica. Usa un objeto para agrupar los 
   objetos por la propiedad dada. */
export function agruparPorPropiedad(array, propiedad) {
    // tu código aquí
}

// Ejercicio 9:
/* Escribe una función que tome una cadena y devuelva la misma cadena con las 
   palabras en orden inverso. Usa el método split() para dividir la cadena en palabras, 
   reverse() para invertir el orden y join() para unir las palabras de nuevo. */
export function invertirPalabras(cadena) {
    // tu código aquí
}

// Ejercicio 10:
/* Escribe una función que tome un array de números y un número objetivo, y devuelva 
   un array de todos los pares de índices cuyos elementos suman el número objetivo. 
   Usa un bucle anidado para encontrar todos los pares de índices. */
export function encontrarParesSumaObjetivo(numeros, objetivo) {
    // tu código aquí
}

// Ejercicio 11:
/* Escribe una función que tome un objeto y devuelva un array de todos los valores 
   únicos en el objeto y sus subobjetos. Usa una función recursiva para recorrer 
   todos los subobjetos. */
export function obtenerValoresUnicosRecursivos(objeto) {
    // tu código aquí
}

// Ejercicio 12:
/* Escribe una función que tome una cadena y devuelva la misma cadena con todas las 
   palabras capitalizadas. Usa el método split() para dividir la cadena en palabras y 
   map() para capitalizar cada palabra. */
export function capitalizarTodasLasPalabras(cadena) {
    // tu código aquí
}

// Ejercicio 13:
/* Escribe una función que tome dos arrays y devuelva un array de elementos que se 
   encuentran en ambos arrays. Usa el método filter() para encontrar los elementos 
   comunes. */
export function interseccionArrays(array1, array2) {
    // tu código aquí
}

// Ejercicio 14:
/* Escribe una función que tome una matriz (array de arrays) y devuelva la transpuesta 
   de la matriz. La transpuesta de una matriz es una nueva matriz cuyas filas son las 
   columnas de la matriz original. */
export function transponerMatriz(matriz) {
    // tu código aquí
}

// Ejercicio 15:
/* Escribe una función que tome un array de números y devuelva el subarray continuo 
   con la suma más grande. Usa el algoritmo de Kadane para resolver el problema. */
export function subarraySumaMaxima(numeros) {
    // tu código aquí
}

// Ejercicio 16:
/* Escribe una función que tome una cadena y devuelva la longitud de la subsecuencia 
   común más larga (LCS) entre esa cadena y otra cadena dada. Implementa el algoritmo 
   de LCS usando programación dinámica. */
export function longitudLCS(cadena1, cadena2) {
    // tu código aquí
}

// Ejercicio 17:
/* Escribe una función que tome una cadena y devuelva true si la cadena es un número 
   palíndromo (se lee igual de adelante hacia atrás y de atrás hacia adelante) y false 
   en caso contrario. */
export function esPalindromoNumerico(cadena) {
    // tu código aquí
}

// Ejercicio 18:
/* Escribe una función que tome un array de números y devuelva el producto máximo de 
   tres números en el array. Usa un enfoque de ordenación para encontrar los tres 
   números más grandes y calcular el producto. */
export function productoMaximoDeTres(numeros) {
    // tu código aquí
}

// Ejercicio 19:
/* Escribe una función que tome una cadena y devuelva la longitud de la subcadena más 
   larga sin caracteres repetidos. Usa un conjunto (Set) para rastrear los caracteres 
   únicos y un puntero deslizante para encontrar la subcadena más larga. */
export function longitudSubcadenaSinRepetidos(cadena) {
    // tu código aquí
}

// Ejercicio 20:
/* Escribe una función que tome un array de enteros y un número k, y devuelva el k-ésimo 
   número más grande del array. Usa una estructura de datos de ordenación eficiente 
   como un heap (montículo) para resolver el problema. */
export function encontrarKEsimoMayor(numeros, k) {
    // tu código aquí
}
